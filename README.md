# Игра - жизнь
Приветствую вас, друзья! меня зовут сергей и мы с вами здесь на этом канале изучаем
0:12
программирование и сегодня мы с вами займемся созданием симуляции жизни скажем так новенькая сишарп плюшка в
0:18
нашу коллекцию это я все к тому что все sharp плюшках может быть все что угодно даже то что мы не учили так вот перед
0:25
вами сейчас игра жизнь которую придумал джон конвей и которую мы с вами сегодня и напишем
0:31
вселенная этого мира эта плоскость которой живут клетки каждая клетка это
0:36
живое существо существуют определенные условия благодаря которым клетка может в этом
0:42
мире существовать благодаря которым может зародиться новая клетка либо же клеткам может погибнуть провела здесь
0:48
простые для поддержания жизни клетки нужны соседи два или три соседа если их
0:54
меньше двух то клетка погибает наверное от одиночества и если и больше чем 3 то
0:59
происходит тоже самое клетка тоже погибает но в этом случае наверное от перенаселение таким образом клетка может
1:06
жить пока у нее есть два или три соседа помимо этого если клетка не занята
1:11
пусто там еще ничего нету никакой жизнь и возле такой пустой клетки которая либо изначально была пуста либо же там была
1:18
какая другая погибшая клетка но сейчас-то ничего нет так вот если возле этой пустой клетки находится 3 живые
1:25
клетки то там зарождается жизнь таким образом жизни в этой вселенной циклическая каждый новый цикл происходит
1:31
проверка вот этих правил для всех клеток в игре и соответственно появляется новые
1:37
клетки погибают старые но либо же для некоторых везунчиков все остается без
1:42
изменения с правилами разобрались теперь еще пара важных моментов код который мы сегодня с вами напишем
1:48
будет требовать рефакторинг ну и понятное дело что сама вселенная можно развивать добавлять новые правила
1:53
модификации все такое проще по понятным причинам тол будут ли эти видео будущем зависит от того насколько вас
2:00
заинтересует конкретно этот ролик от количества просмотров и лайков так что и думал вы знаете что нужно делать но
2:06
независимо от этого для того чтобы понимать почему то кот требуют рефакторинга рекомендую
2:11
почитать две вот эти книги но и как всегда исходный код данного урока для патронов канал с доступом к исходникам
2:17
будет доступен на патреоне и кстати то рекомендую подписаться на мой второй канал ссылку найдете в
2:23
описании ну а теперь к делу давайте нажмем кнопку стоп остановим игру и посмотрим на некий особенности
2:29
которые у нас здесь реализованы у нас здесь есть два параметра resolution идентифик resolution у нас отвечает за
2:36
то какой масштаб нашей вселенной нашего мира то есть чем больше у нас resolution тем
2:43
соответственно крупнее все объекты у нас здесь изображены и соответственно меньшее количество на экране у нас по
2:48
месяца поставим на восьмёрку для примера который я хочу вам показать и теперь посмотрим на density параметра density у
2:55
нас зависит изначально какая плотность населения при генерации первого поколения конкретно в этой реализации
3:02
чем меньше данный параметр чем больше плотность населения двойка здесь у нас минимальное
3:07
значение здесь и сейчас создадим мир в котором будет плотность населения гораздо меньше соответственно данный
3:13
параметр мы увеличим и нажмем кнопку старт и так вот у нас очень маленькая
3:18
плотность населения и хочу сразу же обратить ваше внимание на то что скажем так данный момент но здесь очень много
3:24
стабильных участков здесь есть фигуры состоящий из нескольких клеток которые вообще никак не изменяются и есть фигуры
3:33
которые постоянно изменяются но они извиняются на одном месте такие особенности у нас связаны с тем какие
3:40
собственно правило у данной игры как я уже говорил для того чтобы клетка могла
3:46
поддерживать свою жизнь ей нужно два или три соседа соответственно если два или три соседа у клетки есть то она не может
3:53
умереть и если вы вот посмотрим на какие-то фигуры которые стабильные допустим большой квадрат который состоит
3:59
из четырех клеток то у каждого элемента у каждой клетки которые являются частью
4:04
этого квадрата всегда есть три соседа то есть данном случае каждая клетка этого квадрата поддерживает остальные клетки
4:12
и так как у них нету никаких внешних раздражителей никто не вторгается в их пространство не пытается как-то повлиять
4:19
на их жизни они могут так существовать бесконечно но есть одно маленькое но они не могут дать потомство потому что для
4:27
того чтобы у нас про извелась новая клетка что по зародилась жизнь в клетке где ее нету
4:32
нам необходимо чтобы рядом с этой пустой клеткой были три клетки где жизни есть
4:37
если мы к примеру посмотрим на пустые клетки рядом с этим квадратам то
4:42
становится понятно что у любой пустой клетке рядом с этим квадратам есть качестве соседа если можно так
4:49
выразиться только две клетки есть жизнь а две клетки соответственно зародить по жизни не
4:55
могут соответственно вот благодаря отметим правилам у нас и появляются некие фигуры на мировой карте которые
5:01
могут просто поддерживать свою стабильность они могут жить все вместе если никто им не мешает никто не
5:06
вторгается в их пространство но и дать потомство они не могут но наши реализации игры я предусмотрел возможное
5:13
чтобы мы могли сами создавать их дополнительные клетки пусти мыслимо мышкой это как проведем
5:19
с мы можем добавить новых жителей в наш мир и соответственно мы их можем и удалять
5:25
левой кнопкой мышки мы будем добавлять правой кнопкой мышки ну скажем так удалять удалять что угодно
5:33
уничтожить наш мир так вот если мы рядом с пляжем так с нашим островком
5:38
стабильности вот этим вот квадратом добавим новые жители побольше они могут вторгнуться в эту
5:46
стабильность соответственно вот эти клетки которые были частью этого квадрата не смогут поддерживать свою жизнь стабильную и с ними что-то
5:53
произойдет дальше пойдет развитие помимо этого у нас вот есть такие моменты
5:58
такие регионы из нескольких клеток которые постоянно двигаются опять-таки это тоже связано с понятное дело с
6:05
правилами жизни в нашем мире здесь выходит так что у нас постоянно зарождаются новые клетки потом их
6:11
становится слишком много одна из них умирает и они панова зарождаются при любом случае этот мир всегда стремится
6:19
какой-то стабильности и упорядоченности и скажем так рано или поздно все
6:26
заканчиваются тем что у нас наблюдается либо же островки стабильности которые
6:32
сами могут поддерживать свою жизнь но не могут дать потомство либо же такие островки но скажем так это же
6:38
стабильности который никуда не двигаются на которых постоянно зарождается новая жизнь и погибает старое вот кстати у нас
6:45
пошла колонии путешественников которые сейчас испортила жизнь какому-то строку стабильности но благодаря этому
6:51
зародилась на довольно большое количество новых клеток и собственно жизнь нашей вселенной нет
6:57
кардинально измениться кто знает в общем затем все можно наблюдать бесконечно помимо этого мы можем еще одна сеть
7:03
изменения коррективы в этот мир
7:09
собственно давай посмотрим как все это дело и реализовать приступим к созданию проекта запускаем
7:16
visual studio нажимаем кнопку create a new project и здесь нам нужно найти windows forms of
7:23
на базе did not фреймворк выбираем этот пункт нажимаем next далее нам необходимо указать локейшн то есть место
7:30
расположение нашего проекта на звание самого проекта выбираем версию этот
7:35
фреймворк просто выбираете максимально позднюю версию которая вам доступна и нажимайте next для начала нам необходимо
7:41
набрать интерфейс я эту форму изначально немножечко растяну нам потребуется
7:47
открыть tool-box котором будут все компоненты которые нам протыкает windows forms если у вас данной вкладке tool-box нету
7:54
вам нужно нажать кнопку по видео и выбрать пункт tool-box тогда у вас этот компонент здесь вот
8:00
слева появится прежде всего нам необходим сплит контейнер выбираем его перетягиваем на нашу форму далее нам
8:07
нужно нажать на данный сплит контейнер правой кнопкой мышки нажать пункт properties обратите внимание сплит
8:13
контейнер как бы у нас состоит из самого сплит контейнера и двух ложных элементов папой на владин и по 02
8:19
так вот нам нужно выбирать не понял этим и поймал два именно сам сплит контейнер мы можем либо по разделителем нажать
8:27
мышкой тогда мы выберем сплит контейнер либо же вот справа нам нужно выбрать именно сплит контейнер 1 далее для
8:34
нашего сплит контейнер 1 давайте окажем border style fix 3d таким образом наш
8:40
разделитель станет в поле заметил в левой части у нас будут настройки наши
8:45
игры с правом само игровое поле можем принципе даже формочку немножко увеличить я не хочу чтобы у нас этот
8:52
сплит контейнер двигался он нам нужен скажем так просто для красоты для того чтобы отделить в отдельную часть
8:57
настройки в отдельную часть самой грубой область соответственно вот этот сплиттер нам
9:02
нужно заблокировать опять-таки нам нужно чтобы у нас был выбран сплит контейнер в properties он сейчас называется спид контейнер один
9:09
другого у нас нету параметр из сплиттер fix нам нужно поставить в true и в параметр fixed павел нам нужно поставить
9:16
павел один сохраним наш проект через control of 5 запустим вот он наш интерфейс и вот эту панельку наш свитер
9:23
мы сейчас сдвигать не может принципе мы этого и хотели добиться следующие компоненты который нам потребуется для того чтобы
9:30
мы могли там отрисовывать наше игровое поле нашу вселенную этот picturebox найдем его в боксе перетащим на правую
9:37
панель нас здесь интересует параметр долг выбираем вот это вот центральную часть таким образом его значение
9:43
изменяться в фил и это раз тянет его на всю панель займемся настройками и кнопка
9:50
ну во первых нам понадобится парочка выебав где мы сможем просто хранить текст пока вот в таком виде его и
9:57
оставим и следующий компонент который нам понадобится это компонент на берег
10:02
отдал это вот именно та самая штука которая позволяет нам манипулировать исламе в качестве параметров зайдем
10:08
свойства компонента номере когда он первое что нас здесь интересует это параметр текст оnline я хочу чтобы он
10:14
был райт чтобы число которое выступает нос качестве параметра было с правой стороны этого компонента данный номере
10:20
когда у нас будет отвечать за разрешение то есть за резолюцию поэтому давайте его имя изменим чтобы нам было понятно потом
10:28
к какому компонента обращаться за дамой информации заданными параметрами но мэри когда он я сокращу до аббревиатуры чтобы
10:35
было понятно что это за компоненты еще добавлю слова resolution соответственно мы теперь с вами знаем что вот эта штука
10:41
это у нас на марик of dawn который называется resolution для чего нам это
10:47
было нужно давайте сразу же посмотрим когда у вас открыто вот эта формочка нажимаете клавишу и всем вы можете
10:53
открывать код этой формы и соответственно давайте где-то в конструкторе этой формы просто
11:00
обратимся к нашему компоненту вот смотрите у нас теперь есть компонент на
11:05
3 solution у которого есть обозначения в или соответственно то что вот там в цифрах
11:12
мы поставим будет в этом параметры и у нас таких компонентов может быть несколько соответственно теме на которые
11:18
мы им будем давать потом мы в ходе сможем использовать вернёмся в код формы обратимся теперь к лэйблом лейбла тоже
11:25
есть имя но в коде мы не будем к ним обращаться он для нации носит чисто информативный характер нас интересует
11:32
только его свойство текст собственно здесь мы напишем слово resolution то есть разрешение для того чтобы было
11:38
понятно к чему относится вот это вот штука это у вас разрешение и давайте
11:44
зайдем в его настройки шрифтов фонд пусть у нас будет полужирный наверно
11:49
можно немножечко шрифта увеличить в 10 вот теперь мы можем два этих компонента
11:55
скопировать просто выделяем еще решив нажимаем kontrol ц control-d они у нас копируются мы сюда вот так
12:01
тянем мы их копируем для того чтобы и настраивать потом опять всех параметров вручную потому что нам те же самые
12:08
параметры нужны обратите внимание у нас вот этот лейбл это лейбл 1 2 global
12:14
который мы скопировали это лейбл 2 называются они по-разному на ему у них разные но текст одинаковые поэтому на
12:20
ether интерфейсе мы их видим как будто бы они одинаковые у второго мы текст поменяем 2 лейбл у нас будет описывать
12:27
значения вот этого параметра и здесь у нас будет информация там какая у нас будет плотность населения соответственно
12:33
вот этот на марик up down мы тоже переименуем назовем его над density ты сна мы теперь можем давать
12:39
параметрам регулировать чё парочка нюансов которые мы здесь должны установить ну во первых у нас не может
12:46
здесь быть значения 0 и в разрешении не в density о свойствах но марика
12:52
которые встречаются резолюшн значение максимум давайте ограничим а 25 а
12:58
минимум единицу на самом деле разрешение в единицу у нас будет не совсем рабочим
13:03
вариантом потому что каждая клетка у нас будет занимать один пиксель и все это будет довольно медленно обрабатываться
13:09
поэтому тормозить вот эта двойка это реально рабочий вариант но мы можем
13:15
оставить единицу для того чтобы иметь возможность просто посмотреть как оно все таки будет выглядеть хотя мы будет
13:20
тормозить а для density мы поставим минимальное значение 2
13:25
максимально можно принципе не ограничивать пускай там 100 таки останется помимо этого нам необходимо
13:31
установить дефолтное значение это поле в или для денется тема так и оставим 2 а для
13:37
resolution наверное петра зона вокруг тройки поставить теперь нам необходимо добавить еще парочку кнопок
13:44
вытянем сюда кнопку и стал бокса скопируем и вставим и данной кнопки у нас будут включать за
13:51
start и stop нашей игры нам необходимо поменять их название и давайте кстати поменяем им
13:59
еще и шрифты я выделил сразу две эти кнопки зашел
14:04
настройке функции поставляем полужирный шериф 3 пускай тоже на 10 быть вот как
14:10
то так давайте немножко эти кнопки растянем пускай они будут слегка побольше можем
14:16
даже и вот так сделать и почему нет помимо этих компонентов нам еще
14:21
понадобится и таймер вот такой компонент нажимаем на него два раза кнопкой мышки
14:27
вот здесь внизу у нас добавился нам этот таймер понадобится для того чтобы вызывать события отрисовки и
14:34
генерации новых поколений наших клеток если мы зайдем в пропорции этого таймера
14:40
мы видим что здесь есть интервал это интервал его срабатывания за каждое
14:45
срабатывание этого таймера у нас должно генерироваться новое поколение клеток и соответственно отрисовывается то что
14:52
было сгенерировано кстати давайте немножечко все таки формочку меньшим она
14:57
не помещается у нас полностью я бы этот интервал постоял поменьше где-то назначение 40 миллисекунд
15:03
думаю будет в самый раз теперь зайдем в события этого таймера эванс вот такая
15:08
вот молния здесь есть события тег и в пустое поле просто нажмем два раза кнопкой мышки соответственно у нас
15:14
генерироваться метод который будет вызываться во время этого события из нас
15:19
и будет логика генерации следующего поколения и его отрисовки для кнопок нам тоже необходимо
15:26
подписаться на события клика по этим кнопкам на прежде чем мы это сделаем давайте вернемся в properties
15:32
наших кнопок и переименую их первую кнопку назовем б старт то есть батон
15:39
стару сокращенная вторую кнопку стоп ну
15:45
и теперь жмем 2 раза левой кнопкой мышки по первой кнопки у нас генерируется этот
15:51
где будет обрабатываться событие клика по этой кнопке и для 2 кнопки сделаем то
15:57
же самое в принципе юзер интерфейс у нас уже готов теперь можем приступить непосредственно к реализации логике наши
16:03
игры для начала давайте просто попробуем что-нибудь отрисовать нашем игровом поле просто какой-нибудь квадратик
16:11
для того чтобы понять что скажем так а наша схема рабочие для отрисовки нам
16:16
потребуется класс graphics нам необходимо объявить объект этого класса
16:22
ты давайте пока вот здесь в обработчике события клика по кнопке
16:27
батон старт продолжим писать наш код сейчас пока напишем простенькая логику
16:33
для отрисовки графики потом все это по выносим уже в отдельные методы отрисовывать графику мы будем в нашем
16:40
texture боксе его и свойства и матч идет собственно содержится картинка здесь мы должны
16:46
создать новый bitmap по сути картинку размер картинки должны соответствовать нашему picturebox у поэтому у этого
16:52
picturebox а нам потребуется твой ствовать то есть его ширина пиво него
16:57
уже свойства хайд то есть по высота таким образом в нашем пещер бокса мы создаем новый бит но по факту новую
17:04
картинку далее нам необходимо создать объект graphics и присвоить его вот это
17:10
вот переменную которую мы здесь выше объявили для этого нам необходимо обратиться к классу graphics вызвать
17:16
метод from и матч и в качестве параметра передать им а что самого picturebox а
17:22
которой мы создали на предыдущей строчке кода пир вас есть возможность от рисовать различные примитивные фигуры в нашем случае нас
17:29
интересует кадра для того чтобы что-то отрисовать нам необходимо обратиться к объекту graphics квадрат это скажем так
17:35
один из частных случаев прямоугольника поэтому мы будем вызывать не тот фил
17:41
крик тангл ну то есть заполнить прямоугольник 1 параметр отвечает за только цвет он будет здесь мы обратимся
17:47
классов браш из и и я выбираю цвет crimson это вот тот самый красный цвет который нас отрисовывать все клетки в
17:54
нашей игре в дальнейшем у нас здесь есть несколько перегрузок которые отвечают за начальные координаты прямоугольника
18:00
из-за его ширину и высоту укажем начальные координаты по нулям и качестве
18:06
длины и высоты нам необходимо использовать значение разрешения этот элемент an american down
18:12
именно для этого нам и был необходим давайте под него создадим отдельную переменную
18:19
и соответственно вот здесь нажатие на нашу кнопку еще до создания картинки в эту переменную мы будем
18:27
присваивать значение нашего на марика простите внимание у него тип данный bc мало нам нужен and можем просто
18:34
выполнить приведение типов далее вот эту переменную риза вершин мы передаем
18:39
качестве параметров а при заполнении нашего прямоугольника здесь нас интересует ширина и высота но собственно
18:47
так как мы рисуем квадрат плюс ширина и высота у нас будет одинаковое будет соответствовать значению этого вот параметры resolution теперь мы можем
18:54
запустить нашу программу и нажать кнопочку start сейчас у нас по нажатии
18:59
этой кнопочке просто от рисуется прямоугольник причем где то вот здесь и довольно маленький потому что у нас только в 3 пикселя
19:05
будет его высота и ширина но он там есть давайте по максимуму увеличим resolution сколько
19:11
у нас позволяет ну собственно вот он наш прямоугольник таких прямоугольников нам потребуется очень много
19:17
как то мы будем отрисовывать все клетки нашей силе конечно же отрисовка прямоугольника при нажатии по кнопке
19:25
старт нам не нужно но тем не менее вот эти вот все действия которые инициализирует оси объект который нам
19:31
нужны для тресов графике мы можем оставить я бы хотел а вынести функционал создания
19:37
вообще нашей новой игры с этапа разрешения и всего такого прочего в
19:42
отдельный метод поэтому я этот самый метод создам этому ведь отсюда скопируем
19:48
поместим в этот метод а сам метод start game будем вызывать
19:53
обработчики событий аббатом клик что нам необходимо еще здесь нашем методе start
19:59
game но во первых все события в нашей регенерации следующих поколений все
20:05
отрисовки будут происходить по событию таймера соответственно когда таймер у нас работает тикает скажем так что мы не
20:12
должны иметь возможность создать новую игру соответственно прежде чем выполнять все действия методе start game мы будем
20:18
проверять наш таймер его свойство рен и был и если у нас будет включен то есть
20:23
свойство enabled будет труп ничего не будем делать хотим просто выходить из этого метода
20:29
когда у нас игра уже стартовала мы не должны прямо во время того как она сгенерируется новое поколение
20:35
выполняется отрисовка иметь возможность изменять разрешение или а плотность
20:41
населения но это на самом деле бессмысленно соответственно вот эти две кнопки и два компонента момент нажатия
20:48
кнопки старт у нас будут блокироваться помимо этого нам каким-то образом требуется хранить информацию тоном
20:55
девкой клетки у нас находится какой-то живой организм где у нас пустая клетка и
21:00
соответственно каким-то образом считать их соседи все такое прочее так вот для того чтобы эту информацию хранить нам
21:07
потребуется двумерный массив и нам необходимо определиться какого типа данных этот массива у нас будет в
21:13
текущей реализации этой игры у нас состоянии клетки может быть только два либо на живой либо мертвых либо на там
21:20
есть либо ее нет соответственно для этих целей мы можем использовать тип данных ул который может принимать все значение
21:25
либо да либо нет либо true либо фоллз обеим двумерный массив типа bool по факту этот двумерные массивы
21:32
будет представлять наше игровое поле наша вселенная ну скажем некую табличку
21:37
из клеток я так и назову этот массив фил но то есть поле при создании данного
21:42
массива нам необходимо будет вычислять количество строк и колонок данном
21:47
массиве мы не можем генерировать напрямую количество строк и колонок в массиве от того сколько пикселей у нас в этом
21:54
picturebox ну потому что у нас каждая клетка соответственно будет занимать один пиксель вообще то как бы мы это
21:59
можем делать но нам будет ничего не видно плохо довольно видно которых это будет
22:05
очень медленный работ соответственно именно для этого мы ввели параметр разрешения и
22:10
для того чтобы рассчитывать количество строк и колонок для нашего массива соответственно мы должны создать две
22:16
переменные создавать наше игровое поле мы будем момент старта нашей игры после того как уже нам будет известна
22:22
разрешение то есть перемена resolution присвоенное какое-то значение ну а для того чтобы создать игровое поле
22:28
нам предварительно необходимо рассчитать количество строк колонна как нашем игровом поле соответственно количество
22:34
строк которая у нас должно быть у нас должно зависеть от того какая высота у нас игрового поля то есть вот этого
22:41
нашего picturebox а где у нас будет отрисовывается она также должны зависеть от разрешение которое мы выбрали для
22:47
нашей игры таким образом в переменную rolls мы будем помещать значение поля хайд нашего picturebox а
22:55
деленное на разрешение и соответственно для поле colors у нас будет то же самое
23:01
но только с полем быть далее нам необходимо создать игровое поле то есть
23:08
нашему следу мы нам будет удобнее представлять расположение элементов а то есть по сути клеток в нашем массе будто
23:15
они расположены на координатные плоскости до картера координаты оси xy оси y ну и соответственно при обращении
23:22
к индексом массива мы будем сначала указывать x потом и соответственно когда мы создаем этот массив мы сначала
23:29
указываем размерность колонок затем размерность строк далее после того как
23:34
мы создали массируйте у нас будет храниться информация о всех клетках на игровом поле нам необходимо создать
23:41
первое поколение этих клеток которые у нас там будут храниться для этого мы
23:46
будем использовать генератор случайных чисел мы переберем все все элементы нашего двумерного массива здесь у нас
23:53
ось x здесь у нас ось y да и соответственно предварительно нам необходимо создать
23:59
объект класса random того чтобы генерировать те самые случайные числа и
24:05
соответственно в наш 2-мерный массив по нужным координатам мы должны
24:10
поместить значение либо true либо фоллз то есть есть клетка сгенерировался на или не поэтому
24:16
будем использовать объект класса random и вам этот next нам необходимо ограничивать то какое
24:22
максимальное значение у нас будет в при генерации случайного числа обращаю ваше
24:27
внимание на то что само это максимальное значение в диапазон генерируемых случайных чисел не входит таким образом
24:34
если у нас допустим день сеть по дефолту это два и мы здесь в качестве параметра скажем
24:40
этот самый d incite только сначала приведем его контур потому что там дать ему да у нас будет сгенерировано
24:46
случайное число от 0 до 1 у нас скажем просто случайный выбор между двумя вариантами будет у нас
24:53
сгенерирован элемент или нет так вот если в случае с генерации случайного числа у нас получился 0 то значение у
25:00
нас будет труп и в field мы присвоим собственно это труп и это будет означать
25:06
что мы сгенерировали клетку если допустим в результате генерации
25:12
случайного числа у нас будет сгенерировано единица то оно не будет равна нулю и соответственно сюда мы
25:19
поместим фолз таким образом чем больше у нас вот это значение d incite
25:24
чем больший диапазон генерации случайных чисел тем меньше вероятность тому что
25:29
это случайное число которое будет сгенерировано будет равно нулю соответственно чем меньше изначально
25:36
элементов массива со значением трубу нас будет соответственно чем меньше
25:41
плотность населения у нас будет в первом поколении наших клеток в наших член
25:47
ну и в самом конце когда мы все это выполнили выполнили весь этап нам необходимо
25:53
стартовать наш таймер для того чтобы игра началась снова объекта таймер 1-го
25:59
вызываемые от старт игра начинается давайте поставим здесь где-то breakpoint и вообще посмотрим что у нас здесь будет
26:05
происходить запустим это все дело фдэ баги нажимаем старт таймер у нас был выключен поэтому
26:11
у нас сюда пропустила у нас авторитарным не выполнился у нас выключается элементы
26:17
управления нашими параметрами игры резолюшн и d incite значение resolution присылается в
26:24
переменную resolution мы рассчитываем количество строк и колонок
26:29
наша миссия field то есть сколько элементов в игровом поле у нас общий путь и сколько клеток у нас создается
26:36
двумерный массив под все это дело далее идёт перебор массива двумя циклами
26:41
генерировать случайные числа видите вот один true у нас уже есть
26:47
после того как все это произойдёт у нас создается объект класса и матч объекта 1
26:53
класса graphics и стартует таймер собственно наша игра пошла но
27:00
поделите у нас должна идти обработка найти китай мера ничего ничего нету поэтому у нас пока
27:06
ничего не отрисовывается ну и соответственно мы ничего остановить пока не можешь что мы не реализовали
27:12
обработку кнопки stop итак перед нами тч несколько задач это во-первых реализовать отрисовку всех
27:18
игровых клеток которые у нас есть далее реализовать остановку нашей игры и наверное самое сложное это реализация
27:25
подсчета соседей воздух редки для того чтобы либо же сгенерировать новую клетку либо же решить что наша клетка у которой
27:32
недостаточно у соседей или слишком много соседей должно умереть займемся отрисовкой я хочу и таки все
27:39
это выполнить в отдельном методом назовем его next generation п
27:44
этот метод next generation у нас будет вызываться событий тег ну а собственно
27:50
самом методе каждый раз когда у нас будет тикает таймер у нас будет называться этот метод и в этом методе мы
27:56
собственно будем выполнять расчет следующего поколения и отрисовку того
28:01
что у нас там получилось но во первых каждый раз когда у нас будет сгенерировано новое поколение нам
28:08
необходимо очистить игровое поле поэтому объекта graphics мы будем вызывать метод clear мы должны здесь указать цвет
28:15
которым мы хотим залить всю игровую области я буду все заливать чёрным цветом но так как у нас было изначально
28:21
черный красный вы можете выбирать как вам больше нравится давайте пока просто отрисовку
28:26
сделаем здесь опять-таки нам нужен перебор нашего игрового поля поэтому я просто
28:32
скопирую эти два цикла который у нас там были немножко выше и давайте сделаем вот что если у нас нашем
28:39
массиве field по нужным координатора значения true этот iv у нас выполнится и собственно
28:46
здесь мы можем адресовать прямоугольник так как мы это уже делали в качестве
28:51
начальной точке где у нас будет отрисовывается прямоугольник тогда мы указывали панелям и он у нас был в углу
28:57
а теперь мы будем качестве отступов использовать яндекс нашего элемента в
29:02
массиве умноженный на разрешение таким образом мы эти прямоугольники будем сдвигать по
29:08
нужным координата соответственно у нас x умноженный на resolution y умноженный на
29:14
resolution и далее еще два раза creed iii в revolution для того чтобы
29:20
отрисовать шириной высота прямоугольника далее для того чтобы у нас перед
29:26
рисовалась игровое поле у самого picturebox а нам нужно вызвать метод
29:32
refresh в принципе вот даже сейчас детским и стартанем игру то у нас уже должно отрисоваться игровое поле которое
29:39
у нас изначально была сгенерирована с помощью генератора случайных чисел
29:44
вот она кстати я хочу чтобы наша игра сразу же запускалась a full screen
29:50
скажем так развернутом виде поэтому у нашей формы в дизайне реформ нам
29:56
необходимо изменить параметр windows стоит здесь она normal а нам нужно поменять на максимально
30:01
соответственно теперь когда наша игра будет стартовать у нас всегда она будет развернуто ведь нажимаем кнопочку старты
30:08
и вот собственно изначально игровое поле которое у нас было сгенерировано на самом деле она генерируется каждый тег
30:15
нашего таймера но так как оно не изменяется у нас отрисовывается одно и то же поле в принципе мы можем проверить
30:21
отрабатывает ли смена кадров просто взял этот кусочек кода где он из генерируется
30:27
случайным образом первое поколение вставить его вот сюда [музыка]
30:33
запустить но и соответственно у нас случайным образом будут генерироваться
30:39
прямоугольники нашем игровом поле но восстановить мы все это дело сейчас не можем потому что
30:45
реализация кнопки стоп мы еще не делали давайте стать этим сейчас и займемся создадим метод стопгейм на всякий случай
30:51
будем проверять не включен ли таймер вот если таймер не включен то соответственно нам ничего останавливать и
30:57
соответственно делать ничего не нужно поэтому будем просто выходить из этого метода а если таймер был включен то у
31:03
моего остановим и как вы помните когда мы стартовали игру мы блокировали элементы управления
31:09
которые отвечают за плотность населения и за разрешение соответственно когда мы
31:15
игру останавливаем нам эти элементы управления нужно включать обратно теперь мы сможем включать и выключать игру да
31:21
ещё один маленький нюанс этот стал геем мы должны вызывать в обработчике события батон стоп клик вот чтобы это сработало
31:30
теперь мы можем запускать и останавливать нашу игру не останется у нас сейчас здесь просто
31:36
генерация случайных прямоугольников кстати чем-то смахивает на qr-код но если мы нажимаем стоп а она работает
31:42
если мы к примеру изменим значения d incite тему соответственно плотность наших прямоугольников уже можем изменить
31:50
чем больше у нас до языке еще нас плотность если на максималку
31:55
выкрутим но вот самая маленькая и помимо этого мы можем еще менять разрешение давайте resolution на 25 выкрутим как
32:02
видите мы теперь можем и увеличивать изображение но соответственно у нас меньше количество элементов будет меньше
32:08
клеток на игровом поле но зато они будут крупнее если мы поставим на единицу мы получим вот такую
32:14
вот штуку сейчас мы с вами создали генерацию какого-то шума на по факту у нас с вами уже есть модель нашего мира
32:22
которая хранится нашем массиве у нас уже есть отрисовка нам необходимо только
32:28
реализовать правила по которым будет генерироваться следующее поколение и соответственно игра у нас уже будет
32:33
работать в дальнейшем нашим шагом будет реализация подсчета соседей у каждой
32:39
клетке для того чтобы мы могли моделировать ситуацию должна ли зародится новая жизнь либо же погибнуть
32:45
старые либо же не должно ничего поменять вот этот вот код который мы добавили в мир next generation который у нас просто
32:53
генерировал случайным образом новое игровое поле мы должны сюда убрать потому что это было просто для теста
32:59
займемся реализацией метода подсчета соседей назовем этот метод аккаунт на и bosch подсчитать соседей и сюда мы будем
33:07
принимать два параметра координаты текущего элемента среди которого мы
33:12
хотим подсчитать соответственно нам нужные параметры x и y пока качестве
33:18
заглушки будем всегда возвращать 0 и прежде чем вернемся в дальнейшем к этому методу
33:24
давайте организуем в методе написаны generation ну собственно генерации того самого следующего поколения которые у
33:30
нас должно генерироваться на основе результатов работы вот этого метода здесь у нас будет создаваться новый
33:37
массив двумерный массив типа bool новый массив нам нужен для хранения новых
33:42
данных по той причине что мы не можем изменять данную старом музее старые мы фирмы можем использовать только для того
33:48
чтобы извлечь старые данные произвести на основе их расчеты поместить в новой массив потому что ясно мои в момент
33:55
извлечения из старого массива сразу же будем менять в нем дано это повлияет на расчеты и общем то они будут
34:01
неправильный соответственно здесь каждый раз нужен новый массив которому нас будет генерироваться следующее поколение
34:07
генерации следующего поколения у нас будет происходить вот здесь в этих двух циклах там же где мы сейчас и
34:13
отрисовываем а все наши прямоугольники соответственно здесь мы будем подсчитывать соседей для каждого такого
34:19
элемента и на основании того сколько там было этих самых соседей будем принимать как
34:24
это решение о дальнейшей судьбе того или иного элемента в нашем оси здесь мы будем вызывать метод каунт neighbors
34:31
который мы ещё не реализовали и сюда будем передавать x века это вот координаты того элемента который мы
34:37
сейчас перебираем помимо этого для того чтобы наш код был немножко более понятные здесь мы будем создавать еще одну
34:43
промежуточную перемены но древнюю his life но мы будем помещать информацию о том если какая-то живая клетка
34:49
по текущим координатор если в нашем массиве булевых переменных по текущим
34:55
координатам труд о переменных и zlife будет труп и соответственно вот этот переменной мы можем прямо вот здесь
35:00
кстати использовать в этом эффект просто наш код будет более понятно выглядит
35:06
будет более понятно что здесь происходит здесь у нас будут реализовываться те самые правила по которым генерируются
35:12
следующее поколение для начала если данная клетка свободно то есть переменная х zlife и будет фолз из там
35:19
нету жизни и у данной клетке количество соседей равно 3 то соответственно здесь у нас может зародиться жизнь
35:27
соответственно вот это вот новое поле где у нас будет новая генерация новое
35:32
поколение в этот массив по текущим координатам мы поместим значение true в
35:39
следующем поколении у нас здесь будет новая клетка если же в данной клетке уже есть жизнь и
35:45
количество соседей у этой клетки меньше двух или больше трех то данная клетка у
35:51
нас погибать соответственно в наш массивнее field по данным координатам мы призываем фолз и в
35:57
следующем поколении здесь у нас не будет клетки если же у нас не выполняются не тяните условия то то что у нас было в
36:04
текущей клетки у нас будет и в следующем поколении соответственно в массе руки у нас будет информация о новом поколении
36:11
по тем же координатам мы присваиваем те же данные по тем же координатам которые
36:17
у нас были в предыдущем поколении нашей переменной field и вот после того как вот это вся логика
36:23
выполнится как у нас все это дело от рисуется мы должны в наш массив field
36:29
вот здесь после всех циклов присвоить наш новый массив you felt таким образом
36:35
следующее поколение которое может здесь рассчитали станет текущим поколением но поставках моего сгенерировали мы
36:42
кстати мы можем немножечко сократить данный код убрать лишние скобки кот станет компот мне
36:47
перевернемся к методу каунт nipples сюда мы передаем координаты текущие клетки и
36:53
нам нужно посчитать количество ее ближайших соседей слева справа сверху
36:58
снизу ну и соответственно по диагонали здесь у нас должна быть переменная которое будет на сохранить самое
37:05
количество и которые мы в конце будем возвращать как результат ну и соответственно сами подсчет нам
37:10
потребуется два положенных цикла начальное значение каждого цикла будет -1 и каждый цикл будет выполняться до
37:18
тех пор пока значение переменной его итератора меньше 2 соответственно этот
37:24
цикл выполнится три раза и нам нужен такой же вложенный цикл который тоже выполнится три раза для чего нам нужны
37:31
два эти цикла раз у нас имеется два выходящих параметра которые нам говорят о
37:36
координатах наше текущее клетки и если мы допустим говорим о координате x по
37:41
горизонтали от неё виде news от этого параметра мы можем получить информацию о соседи слева а добавив единицу среди
37:48
справа таким образом если мы сделаем вот такую вещь
37:54
то соответственно мы пробежимся по всем соседям и по диагонали и слева и справа
37:59
ну потому что у нас вложенный цикл который обойдут все элементы в игровом поле он вокруг нашей текущей клетки но
38:05
есть также один небольшой нюанс эти два цикла когда они будут отрабатывать также обратятся и к координатам нашей текущей
38:11
клетки поэтому если мы будем обращаться координатам наши текущие клетки нам ни в коем случае нельзя ее считать для этого
38:18
дела мы заведем отдельную переменную разъеме из слв checking и собственно будем
38:24
проверять это таким образом если у нас колонка по которой мы бежим вот это вот
38:31
переменные который мы посчитали до равна координате x текущие клетки и строка
38:37
равна координате y текущей клетки то соответственно это
38:42
означает что мы проверяем сами себя и мы в подсчет соседей самого себя не должны
38:48
включать именно ту клетку вокруг которой мы проверяем соседей таки можем здесь
38:54
все на варпа заменить также задача данного метода является подсчитать живых
38:59
соседей соответственно если у нас и живая клетка в качестве соседа
39:04
то в массиве field по данным координатам у нас будет значение труп то значение мы поместим в переменных узлах
39:11
для того чтобы было понятней что мы там нашли и было понять ее дальнейшее нашел если у нас данной клетке есть жизнь his
39:19
life и это не самопроверка то есть не сел в checking the мы можем добавить
39:25
единица к нашему счетчику мы нашли живого соседа и вот эти вот скобки на где снижение теперь нам нужно
39:33
еще раз вернуться к вот этим двум переменным по той причине что у нас здесь не учитывается такая ситуация если
39:40
допустим переменная x это 0 ну то есть клетка соседи которых мы ищем
39:46
в самом левом углу то отняв от этой клеит единицу то есть добавить -1 к нулю мы получим
39:53
отрицательное значение мы выйдем за границу массива и получим ошибку в
39:58
принципе если мы это сейчас запустим мы сразу же видим что мы получили эту ошибку давайте представим что у нас
40:03
игровое поле это хоть и прямоугольник но это все таки
40:09
shark будто бы планета то есть как будто бы эта карта если мы хотим узнать
40:15
информация о соседи слева но там соседа слева не тот а значит это самый крайний
40:20
правый сосед с другой стороны карты то есть вы же знаете когда вы смотрите на карту мира что если слева карта мира
40:26
закончилась но справа все равно то же самое будет да если вы зайдете за левый край нас здесь ситуация такая же
40:33
и чтобы это учитывает нам необходимо модифицировать расчет вот этих вот наших двух координат
40:38
кол и ru и для этого мы сделаем вот что там где у нас рассчитывается колонке мы будем
40:44
добавлять количество всех колонок в нашем массиве которые есть и выполнять операцию остатка от деления такая вот
40:51
формула и то же самое мы должны сделать для примерного это позволит нам заглянуть за край карты
40:57
и скажем так вылезти с другой стороны и посмотреть какой сосед у нас находится с по таким образом на сход уже должен
41:04
работать я напоминаю что метод каунт на и брус у нас вызывается вот здесь там где у нас выполняются генерации
41:11
следующего поколения в общем если мы это все сейчас запустим
41:16
то наш мир уже должен работать что собственно он и делает
41:23
он поставить на паузу изменить разрешение
41:31
изменить density из плотность нашего населения но при плотности 35
41:39
оса в мире может вообще быть очень пусто парочка нюансов которые нам нужно еще от
41:44
допилить так сказать а вручную с помощью левой кнопки мышки заселять наш мир
41:49
новыми клетками и удалять клетки из мира правой кнопкой мышки и соответственно
41:55
помимо этого я бы хотела еще добавить и счетчик генерации вот сюда где у нас название form1
42:01
ну то есть не генерация поколений кстати только что заметил что систем drawing у нас уже был подключен
42:07
соответственно второе подключение здесь не нужно можем просто не нужно using убрать и для того чтобы подсчитывать
42:13
поколения давайте добавим здесь еще одну переменную count generation
42:19
по умолчанию она у нас будет иметь значение 0 когда мы стартуем игру мы
42:26
сюда тоже будем присваивать но это нам нужно для того чтобы сбрасывать счетчик если до этого у нас уже была какая-то
42:31
игра и в поле текст мы будем помещать вот такой текст уже на решен и сюда
42:38
временной карен generation вот этот код мы еще раз скопируем и мы можем его
42:44
поместить в наш метод next generation вот сюда но только здесь будем выполнять еще и
42:51
инкремент таким образом и если мы сейчас запустим нашу игру то сверху
42:57
мы будем видеть какое текущее поколение в нашей игре если мы нажмём на стоп запустим заново
43:03
колени у нас тоже сбрасывается эти добавим возможность заселять наш мир
43:09
новыми клетками и уничтожать старой клетки для этого нам нужно добавить обработчик события у нашего
43:16
picturebox а нас интересует маус мув вот здесь в пустом месте жмакаем не
43:22
собственно вот он наш обработчик события во первых изначально нам здесь нужно добавить заглушку что если у нас таймер
43:29
выключен мы не должны ничего делать ну что в этом нет смысла что-то там делать обновлять какие-то данные если у нас
43:35
игра не идет то есть мы ничего не сможем заселить ничего не сможем удалить далее если у нас событий picturebox мало слов
43:42
принимает аргументы я в этих аргументах у нас есть информация о том как клавиша
43:48
нажата то есть если мы держим кнопку мышки и двигаем саму мышку в пойдем в
43:53
обработчик этого события и если мы держим левую кнопку мышки там и
43:59
соответственно здесь должны добавить новый элемент в нашей игровой пол соответственно нам необходимо найти
44:05
координаты x и y для нашего массива для того чтобы это сделать переменной е
44:10
типа маус каммингс мы должны обратиться к полю локейшн x и разделить ее на
44:17
резолюцию самый resolution который мы сами с вами указываем в качестве разрешения для нашей игры тоже самое нам
44:25
необходимо сделать для y а ну и дальнейшем массив field по нужным координатам если мы с вами добавляем
44:33
клетку нам нужно установить значение труп этот код не нужен еще раз скопировать и я про кнопки мышки
44:40
тоже берем координаты и но только значение фолз таким образом мы здесь будем удалять элемент в массиве
44:47
соответственно с игрового поля клетка исчезнет эти запустим попробуем разрешение немножко побольше поставим и
44:53
density как-то так чтобы у нас не было самым мог из жильцов так сначала правой
44:59
кнопкой мышки ударили дело кнопкой мышки добавили все хорошо все бы хорошо но
45:05
если мы будем держать какую то из наших двух кнопок мышки события которой мы обрабатываем и уйдем
45:13
закрываю область то мы получим исключение потому что события все равно вызывается да мы двигаем мышку даже если
45:19
мы зашли за picturebox соответственно мы берем координаты делим их на resolution
45:24
а в массе а в нашем такого элемента нету для того чтобы избежать этой ошибки мы напишем с вами простенький валидатор
45:31
который проверяют границы выхода за picturebox создадим под это дело отдельный метод он у нас будет возвращать bull землю
45:39
вылетает мал с позиций и собственно здесь у нас будут те самые координаты которые мы хотим во лидировать нас
45:44
координата по иксу должны быть больше равны нулю и y тоже должен быть больше
45:51
равно нулю помимо этого значение игру нас должно быть меньше чем вообще возможное количество колона кино чего выйдем за
45:58
границы массива ее значение y должно быть меньше чем количество строк иначе мы выйдем за
46:04
границы массива вот и весь валидатор у нас будет сразу проверяться вот это вооружение и будет возвращаться
46:10
результат этой проверки прежде чем мы будем выполнять какое-то действие с нашем игровом поле мы сначала будем
46:16
обращаться к нашему валидатор для того чтобы проверять результаты валидации создадим переменную в людей шин по ст
46:22
называем наш валидатор хвали дают мало с позиций придаем туда координаты x y и
46:27
если прошли валидацию в людей шин past the мы будем выполнять
46:32
этот код если же не прошли то просто ничего не произойдет и здесь вот тоже самое добавим только фолз кстати у нас
46:40
здесь получился дублирующиеся однообразные код и его неплохо было вынести был один метод но это скажем к
46:46
вопросу рефакторинга о котором я говорил в начале этого видео это так небольшая
46:52
подсказочка давайте запустим нашу игру теперь возможность добавлять новые клетки у нас сохранилось удалять тоже
47:00
пробуем выйти за границы все а тут ничего не вылетает ну и небольшой
47:09
финальный штрих у нас при запуске наш игры нашего мира том месте где он и выводим
47:17
текущее поколение отпись form1 это как бы не очень красиво соответственно мы добавим обработчик
47:23
события лот когда наша форма будет загружена ну то есть данном случае наша игра
47:30
мое поле текста будем присылать сообщения generation и значение переменной коран даже на лишь томас ноль
47:37
значит соответственно при начальном запуске нашей игре у нас будет из надписи generation 0
47:43
вот как то так тронов канала с доступом к исходному коду все исходники будут доступны на
47:50
патреоне если вам понравилась данное видео вы хотите подобных видео продолжение развития этой темы то не
47:56
забудьте поставить лайк если у вас есть желание поддержать меня и канал финансово информация там как это сделать а дети внизу в описании буду рад если
48:03
поделитесь этим уроком за своими друзьями ну и конечно если вы еще не подписались то подписывайтесь на канал
48:09
здесь уже есть и будет еще много полезных и интересных уроков для вас всем спасибо за внимание пока